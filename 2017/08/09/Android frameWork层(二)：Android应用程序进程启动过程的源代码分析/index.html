<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Android进程启动过程，入口ActivityThread.main函数，binder进程间通信">
<meta property="og:type" content="article">
<meta property="og:title" content="Android frameWork层(二):Android应用程序进程启动过程的源代码分析">
<meta property="og:url" content="http://yoursite.com/2017/08/09/Android frameWork层(二)：Android应用程序进程启动过程的源代码分析/index.html">
<meta property="og:site_name" content="紫阳的博客">
<meta property="og:description" content="Android进程启动过程，入口ActivityThread.main函数，binder进程间通信">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://hi.csdn.net/attachment/201109/5/0_1315236533f7n7.gif">
<meta property="og:updated_time" content="2017-08-20T15:16:09.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android frameWork层(二):Android应用程序进程启动过程的源代码分析">
<meta name="twitter:description" content="Android进程启动过程，入口ActivityThread.main函数，binder进程间通信">
<meta name="twitter:image" content="http://hi.csdn.net/attachment/201109/5/0_1315236533f7n7.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/08/09/Android frameWork层(二)：Android应用程序进程启动过程的源代码分析/"/>





  <title>Android frameWork层(二):Android应用程序进程启动过程的源代码分析 | 紫阳的博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">紫阳的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/09/Android frameWork层(二)：Android应用程序进程启动过程的源代码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dehao@yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1502346421&di=d5dddcc8504e58a709921075437056f6&imgtype=jpg&er=1&src=http%3A%2F%2Fww2.sinaimg.cn%2Fmw1024%2F64b5b174jw1esy5043qmtg206t07i7ol.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="紫阳的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android frameWork层(二):Android应用程序进程启动过程的源代码分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-09T22:10:37+08:00">
                2017-08-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/08/09/Android frameWork层(二)：Android应用程序进程启动过程的源代码分析/" class="leancloud_visitors" data-flag-title="Android frameWork层(二):Android应用程序进程启动过程的源代码分析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          
              <div class="post-description">
                  Android进程启动过程，入口ActivityThread.main函数，binder进程间通信
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <a id="more"></a>
<h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>Android应用程序框架层创建的应用程序进程具有两个特点：</p>
<ul>
<li>一是进程的入口函数是ActivityThread.main；</li>
<li>二是进程天然支持Binder进程间通信机制；<br>这两个特点都是在进程的初始化过程中实现的，本文将详细分析android应用程序进程创建过程中是如何实现这两个特点的。</li>
</ul>
<p>Android应用程序框架层创建的应用程序进程的入口函数是ActivityThread.main比较好理解，即进程创建完成之后，Android应用程序框架层就会在这个进程中将ActivityThread类加载进来，然后执行它的main函数，这个main函数就是进程执行消息循环的地方了；</p>
<p>Android应用程序框架层创建的应用程序进程天然支持Binder进程间通信机制这个特点应该怎么样理解呢？我们在第一篇<a href="">Android frameWork层 (一)：Android 进程间通信学习</a>,它具有四个组件：分别是驱动程序、守护进程、Client以及Server，其中Server组件在初始化时必须进入一个循环中不断地与Binder驱动程序进行到交互，以便获得Client组件发送的请求。</p>
<h4 id="2-启动过程分析"><a href="#2-启动过程分析" class="headerlink" title="2.启动过程分析"></a>2.启动过程分析</h4><p>在Android应用程序框架层中，是由ActivityManagerService(AMS)组件负责为Android应用程序创建新的进程的，它本来也是运行在一个独立的进程之中，不过这个进程是在系统启动的过程中创建的，当系统决定要在一个新的进程中启动Activity或者service的时候，就会创建一个进程。</p>
<p>ActivityManagerService源码分析：</p>
<ul>
<li>1.ActivityManagerService实例调用</li>
</ul>
<p>AMS创建启动过程是在SystemServer负责的，而SystemServer是Android系统服务的管理类，负责服务的启动：包括AMS,PMS，DMS等等分别会执行：startBootstrapServices(),startCoorServices(),startOtherServices();ActivityManagerService在startBootstrapServices启动，这里也包括：PowerManagerService、DisplayManagerService、PackageManagerService</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private void startBootstrapServices() &#123;</div><div class="line">.......</div><div class="line">//1.获取ActivityManagerService服务的实例</div><div class="line">mActivityManagerService = mSystemServiceManager.startService(              </div><div class="line">ActivityManagerService.Lifecycle.class).getService(); </div><div class="line">//把AMS实例加入到服务管理类SystemServiceManager统一管理</div><div class="line">mActivityManagerService.setSystemServiceManager(mSystemServiceManager); </div><div class="line">//执行安装器先关类(Installer/InstallConnection)安装apk路径的apk文件</div><div class="line">mActivityManagerService.setInstaller(installer);</div><div class="line">.......</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看下Lifecycle类：继承SystemService，它是一个控制低优先级服务的实用工具</p>
<p>Lifecycle是ActiityManagerService的内部类，里面是对AMS创建以及启动过程，所以调用getService()方法会获得AMS的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public static final class Lifecycle extends SystemService &#123;</div><div class="line">private final ActivityManagerService mService;</div><div class="line"></div><div class="line">public Lifecycle(Context context) &#123;//创建AMS实例</div><div class="line">super(context);</div><div class="line">mService = new ActivityManagerService(context);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void onStart() &#123;//启动服务</div><div class="line">mService.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public ActivityManagerService getService() &#123;</div><div class="line">return mService;//返回AMS实例</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>2.ActivityManagerService 源码分析<br>先看看构造函数具体初始化了什么：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public ActivityManagerService(Context systemContext) &#123;</div><div class="line">mContext = systemContext;//context</div><div class="line">mSystemThread = ActivityThread.currentActivityThread();//当前线程</div><div class="line">.....</div><div class="line"></div><div class="line">mHandlerThread = new ServiceThread(TAG,</div><div class="line">android.os.Process.THREAD_PRIORITY_FOREGROUND, false /*allowIo*/);</div><div class="line">mHandlerThread.start();//启动</div><div class="line">mHandler = new MainHandler(mHandlerThread.getLooper());</div><div class="line">mUiHandler = new UiHandler();</div><div class="line">//前后台广播消息队列由MainHander处理分发</div><div class="line">mFgBroadcastQueue = new BroadcastQueue(this, mHandler,</div><div class="line">&quot;foreground&quot;, BROADCAST_FG_TIMEOUT, false);</div><div class="line">mBgBroadcastQueue = new BroadcastQueue(this, mHandler,</div><div class="line">&quot;background&quot;, BROADCAST_BG_TIMEOUT, true);</div><div class="line">.......</div><div class="line">//创建进程CPU运行线程监听cpu运行；</div><div class="line">mProcessCpuThread = new Thread(&quot;CpuTracker&quot;)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建了mHandlerThread：具有Looper的循环处理消息的线程；继续创建了MainHandler和UiHandler处理消息；mProcessCpuThread，当然还有初始化电池mBatteryStatsService服务，获取耗电量信息，进程状态服务ProcessStatsService，AppOpsService服务，读取AtomicFile文件等等。</p>
<p><a href="http://blog.csdn.net/Luoshengyang/article/details/6747696" target="_blank" rel="external">Android应用程序进程启动过程的源代码分析</a></p>
<p>ActivityManagerService启动新的进程是从其成员函数startProcessLocked开始的，在深入分析这个过程之前，我们先来看一下进程创建过程的序列图，然后再详细分析每一个步骤。</p>
<p><img src="http://hi.csdn.net/attachment/201109/5/0_1315236533f7n7.gif" alt="image"></p>
<ul>
<li>3.ActivityManagerService.startProcessLocked</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public final class ActivityManagerService extends ActivityManagerNative    </div><div class="line">implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;    </div><div class="line"></div><div class="line">......    </div><div class="line"></div><div class="line">private final void startProcessLocked(ProcessRecord app,    </div><div class="line">String hostingType, String hostingNameStr) &#123;    </div><div class="line"></div><div class="line">......    </div><div class="line"></div><div class="line">try &#123;    </div><div class="line">int uid = app.info.uid;    </div><div class="line">int[] gids = null;    </div><div class="line">try &#123;    </div><div class="line">gids = mContext.getPackageManager().getPackageGids(    </div><div class="line">app.info.packageName);    </div><div class="line">&#125; catch (PackageManager.NameNotFoundException e) &#123;    </div><div class="line">......    </div><div class="line">&#125;    </div><div class="line"></div><div class="line">......    </div><div class="line"></div><div class="line">int debugFlags = 0;    </div><div class="line"></div><div class="line">......    </div><div class="line">if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;;</div><div class="line">//1.启动进程：Zygote进程负责启动新的应用程序进程</div><div class="line">checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;);    </div><div class="line">//2.Process.start参数：ActivityThread字符串，进程name</div><div class="line">//uid，gids，保存应用数据路径</div><div class="line">Process.ProcessStartResult startResult = Process.start(entryPoint,</div><div class="line">app.processName, uid, uid, gids, debugFlags, mountExternal,</div><div class="line">app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</div><div class="line">app.info.dataDir, entryPointArgs);   </div><div class="line"></div><div class="line">......    </div><div class="line"></div><div class="line">&#125; catch (RuntimeException e) &#123;    </div><div class="line"></div><div class="line">......    </div><div class="line"></div><div class="line">&#125;    </div><div class="line">&#125;    </div><div class="line"></div><div class="line">......    </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它调用了Process.start函数开始为应用程序创建新的进程，注意，它传入一个第一个参数为”android.app.ActivityThread”，这就是进程初始化时要加载的Java类了，把这个类加载到进程之后，就会把它里面的静态成员函数main作为进程的入口点，后面我们会看到。</p>
<ul>
<li>4.Process.start </li>
</ul>
<p>这个函数定义在frameworks/base/core/java/android/os/Process.java文件中：<br>这个类的作用是：管理Android系统进程的工具类；</p>
<p>//管理系统进程类：包括各个功能UID、线程优先级、信号量定义、Zygote进程状态ZygoteState类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class Process &#123;</div><div class="line"></div><div class="line">.......</div><div class="line">public static final ProcessStartResult start(final String processClass,</div><div class="line">final String niceName,</div><div class="line">int uid, int gid, int[] gids,</div><div class="line">int debugFlags, int mountExternal,</div><div class="line">int targetSdkVersion,</div><div class="line">String seInfo,</div><div class="line">String abi,</div><div class="line">String instructionSet,</div><div class="line">String appDataDir,</div><div class="line">String[] zygoteArgs) &#123;</div><div class="line">try &#123;</div><div class="line">return startViaZygote(processClass, niceName, uid, gid, gids,</div><div class="line">debugFlags, mountExternal, targetSdkVersion, seInfo,</div><div class="line">abi, instructionSet, appDataDir, zygoteArgs);</div><div class="line">&#125; catch (ZygoteStartFailedEx ex) &#123;</div><div class="line">Log.e(LOG_TAG,</div><div class="line">&quot;Starting VM process through Zygote failed&quot;);</div><div class="line">throw new RuntimeException(</div><div class="line">&quot;Starting VM process through Zygote failed&quot;, ex);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">........</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很简单直接调用startViaZygote方法：Starts a new process via the zygote mechanism.t通过Zygote进程启动一个新的进程；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">public class Process &#123;</div><div class="line"></div><div class="line">.......</div><div class="line">//通过Zygote进程启动新的进程</div><div class="line">private static ProcessStartResult startViaZygote(final String processClass,</div><div class="line">final String niceName,</div><div class="line">final int uid, final int gid,</div><div class="line">final int[] gids,</div><div class="line">int debugFlags, int mountExternal,</div><div class="line">int targetSdkVersion,</div><div class="line">String seInfo,</div><div class="line">String abi,</div><div class="line">String instructionSet,</div><div class="line">String appDataDir,</div><div class="line">String[] extraArgs)</div><div class="line">throws ZygoteStartFailedEx &#123;</div><div class="line">synchronized(Process.class) &#123;//同步锁操作</div><div class="line">ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;();</div><div class="line">//Zygote启动进程需要的参数</div><div class="line">// --runtime-args, --setuid=, --setgid=,</div><div class="line">// and --setgroups= must go first</div><div class="line">argsForZygote.add(&quot;--runtime-args&quot;);</div><div class="line">argsForZygote.add(&quot;--setuid=&quot; + uid);</div><div class="line">argsForZygote.add(&quot;--setgid=&quot; + gid);</div><div class="line">if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) &#123;</div><div class="line">argsForZygote.add(&quot;--enable-jni-logging&quot;);</div><div class="line">&#125;</div><div class="line">if ((debugFlags &amp; Zygote.DEBUG_ENABLE_SAFEMODE) != 0) &#123;</div><div class="line">argsForZygote.add(&quot;--enable-safemode&quot;);</div><div class="line">&#125;</div><div class="line">if ((debugFlags &amp; Zygote.DEBUG_ENABLE_DEBUGGER) != 0) &#123;</div><div class="line">argsForZygote.add(&quot;--enable-debugger&quot;);</div><div class="line">&#125;</div><div class="line">if ((debugFlags &amp; Zygote.DEBUG_ENABLE_CHECKJNI) != 0) &#123;</div><div class="line">argsForZygote.add(&quot;--enable-checkjni&quot;);</div><div class="line">&#125;</div><div class="line">if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JIT) != 0) &#123;</div><div class="line">argsForZygote.add(&quot;--enable-jit&quot;);</div><div class="line">&#125;</div><div class="line">if ((debugFlags &amp; Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) &#123;</div><div class="line">argsForZygote.add(&quot;--generate-debug-info&quot;);</div><div class="line">&#125;</div><div class="line">if ((debugFlags &amp; Zygote.DEBUG_ENABLE_ASSERT) != 0) &#123;</div><div class="line">argsForZygote.add(&quot;--enable-assert&quot;);</div><div class="line">&#125;</div><div class="line">if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123;</div><div class="line">argsForZygote.add(&quot;--mount-external-default&quot;);</div><div class="line">&#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) &#123;</div><div class="line">argsForZygote.add(&quot;--mount-external-read&quot;);</div><div class="line">&#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) &#123;</div><div class="line">argsForZygote.add(&quot;--mount-external-write&quot;);</div><div class="line">&#125;</div><div class="line">argsForZygote.add(&quot;--target-sdk-version=&quot; + targetSdkVersion);</div><div class="line"></div><div class="line">//TODO optionally enable debuger</div><div class="line">//argsForZygote.add(&quot;--enable-debugger&quot;);</div><div class="line"></div><div class="line">// --setgroups is a comma-separated list</div><div class="line">if (gids != null &amp;&amp; gids.length &gt; 0) &#123;</div><div class="line">StringBuilder sb = new StringBuilder();</div><div class="line">sb.append(&quot;--setgroups=&quot;);</div><div class="line"></div><div class="line">int sz = gids.length;</div><div class="line">for (int i = 0; i &lt; sz; i++) &#123;</div><div class="line">if (i != 0) &#123;</div><div class="line">sb.append(&apos;,&apos;);</div><div class="line">&#125;</div><div class="line">sb.append(gids[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">argsForZygote.add(sb.toString());</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (niceName != null) &#123;</div><div class="line">argsForZygote.add(&quot;--nice-name=&quot; + niceName);</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (seInfo != null) &#123;</div><div class="line">argsForZygote.add(&quot;--seinfo=&quot; + seInfo);</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (instructionSet != null) &#123;</div><div class="line">argsForZygote.add(&quot;--instruction-set=&quot; + instructionSet);</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (appDataDir != null) &#123;</div><div class="line">argsForZygote.add(&quot;--app-data-dir=&quot; + appDataDir);</div><div class="line">&#125;</div><div class="line"></div><div class="line">argsForZygote.add(processClass);</div><div class="line"></div><div class="line">if (extraArgs != null) &#123;</div><div class="line">for (String arg : extraArgs) &#123;</div><div class="line">argsForZygote.add(arg);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//把这些进程需要的参数由Zygote进程fork并获得创建进程的结果</div><div class="line">return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数将创建进程的参数放到argsForZygote列表中去，如参数”–runtime-init”表示要为新创建的进程初始化运行时库，然后调用zygoteSendArgsAndGetResult函数进一步操作。</p>
<ul>
<li>5.Process.zygoteSendArgsAndGetResult()：<br>它将启动一个新的子进程，并返回该子pid。请注意:当前的实现用空格替代了参数列表中的新行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">private static ProcessStartResult zygoteSendArgsAndGetResult(</div><div class="line">ZygoteState zygoteState, ArrayList&lt;String&gt; args)</div><div class="line">throws ZygoteStartFailedEx &#123;</div><div class="line">.......</div><div class="line">//获取BufferedWriter、DataInputStream输入流</div><div class="line">final BufferedWriter writer = zygoteState.writer;</div><div class="line">final DataInputStream inputStream = zygoteState.inputStream;</div><div class="line">//</div><div class="line">writer.write(Integer.toString(args.size()));</div><div class="line">writer.newLine();</div><div class="line"></div><div class="line">//for循环取得传入的参数并写入到Zygote进程中</div><div class="line">int sz = args.size();</div><div class="line">for (int i = 0; i &lt; sz; i++) &#123;</div><div class="line">String arg = args.get(i);</div><div class="line">if (arg.indexOf(&apos;\n&apos;) &gt;= 0) &#123;</div><div class="line">throw new ZygoteStartFailedEx(</div><div class="line">&quot;embedded newlines not allowed&quot;);</div><div class="line">&#125;</div><div class="line">writer.write(arg);</div><div class="line">writer.newLine();</div><div class="line">&#125;</div><div class="line"></div><div class="line">.....</div><div class="line">// Should there be a timeout on this?</div><div class="line">ProcessStartResult result = new ProcessStartResult();</div><div class="line">result.pid = inputStream.readInt();</div><div class="line">if (result.pid &lt; 0) &#123;//pid 小于0 新进程fork失败</div><div class="line">throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);</div><div class="line">&#125;</div><div class="line">result.usingWrapper = inputStream.readBoolean();</div><div class="line">return result;</div><div class="line">.......</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里由ZygoteState类与Zygote进程通信交流的状态我们看下这个ZygoteState内部类：内部维护着LocalSocket，DataInputStream，BufferedWriter，abiList</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public static class ZygoteState &#123;</div><div class="line">final LocalSocket socket;</div><div class="line">final DataInputStream inputStream;</div><div class="line">final BufferedWriter writer;</div><div class="line">final List&lt;String&gt; abiList;</div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line">public static ZygoteState connect(String socketAddress) throws IOException &#123;</div><div class="line">......</div><div class="line"></div><div class="line">try &#123;</div><div class="line">zygoteSocket.connect(new LocalSocketAddress(socketAddress,</div><div class="line">LocalSocketAddress.Namespace.RESERVED));</div><div class="line">......</div><div class="line"></div><div class="line">String abiListString = getAbiList(zygoteWriter, zygoteInputStream);</div><div class="line">Log.i(&quot;Zygote&quot;, &quot;Process: zygote socket opened, supported ABIS: &quot; + abiListString);</div><div class="line"></div><div class="line">return new ZygoteState(zygoteSocket, zygoteInputStream, zygoteWriter,</div><div class="line">Arrays.asList(abiListString.split(&quot;,&quot;)));</div><div class="line">&#125;</div><div class="line">......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用LocalSocket 的connect方法通信:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class LocalSocket implements Closeable &#123;</div><div class="line">.......</div><div class="line">//调用这个方法会将这个socket套接字连接到一个端点，这个只能被连接到未连接的实例</div><div class="line">public void connect(LocalSocketAddress endpoint) throws IOException &#123;</div><div class="line">synchronized (this) &#123;</div><div class="line">if (isConnected) &#123;//如果连接了 抛异常</div><div class="line">throw new IOException(&quot;already connected&quot;);</div><div class="line">&#125;</div><div class="line">//是否需要创建LocalSocketImpl实例</div><div class="line">implCreateIfNeeded();</div><div class="line">//连接socket</div><div class="line">impl.connect(endpoint, 0);</div><div class="line">isConnected = true;</div><div class="line">isBound = true;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LocalSocketImpl这个实现类用作LocalSocket和LocalServerSocket，implCreateIfNeeded()方法就是创建Socket；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void create (int sockType) throws IOException &#123;</div><div class="line">.......</div><div class="line">fd = Os.socket(OsConstants.AF_UNIX, osType, 0);</div><div class="line">......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用OS创建socket通信，而维护这个Socket由frameworks/base/core/java/com/android/internal/os/ZygoteInit.java文件中的ZygoteInit类在registerZygoteSocket函数侦听的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class ZygoteInit &#123;</div><div class="line">........</div><div class="line">private static void registerZygoteSocket(String socketName) &#123;</div><div class="line">if (sServerSocket == null) &#123;//判空</div><div class="line">int fileDesc;</div><div class="line">final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;//serversocket的name</div><div class="line">try &#123;</div><div class="line">String env = System.getenv(fullSocketName);</div><div class="line">fileDesc = Integer.parseInt(env);</div><div class="line">&#125; catch (RuntimeException ex) &#123;</div><div class="line">throw new RuntimeException(fullSocketName + &quot; unset or invalid&quot;, ex);</div><div class="line">&#125;</div><div class="line"></div><div class="line">try &#123;</div><div class="line">FileDescriptor fd = new FileDescriptor();</div><div class="line">fd.setInt$(fileDesc);</div><div class="line">sServerSocket = new LocalServerSocket(fd);</div><div class="line">&#125; catch (IOException ex) &#123;</div><div class="line">throw new RuntimeException(</div><div class="line">&quot;Error binding to local socket &apos;&quot; + fileDesc + &quot;&apos;&quot;, ex);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">........</div><div class="line">//等待命令连接ServerSocket</div><div class="line">private static ZygoteConnection acceptCommandPeer(String abiList) &#123;</div><div class="line">try &#123;</div><div class="line">return new ZygoteConnection(sServerSocket.accept(), abiList);</div><div class="line">&#125; catch (IOException ex) &#123;</div><div class="line">throw new RuntimeException(</div><div class="line">&quot;IOException during accept()&quot;, ex);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注册服务socket监听Zygote命令连接，创建LocalServerSocket实例监听socket连接，内部会调用ZygoteConnection,等待socket的连接；</p>
<p>ZygoteInit类:它的入口main函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">1.registerZygoteSocket(name)注册ServerSocket，连接，</div><div class="line">关闭closeServerSocket操作</div><div class="line">2.preload();预加载类，资源，OpenGL，SharedLibraries，文本资源</div><div class="line">，prepareWebViewInZygote，preloadColorStateLists，preloadDrawables</div><div class="line">图片资源，颜色资源</div><div class="line">3.Zygote进程初始化成功： SamplingProfilerIntegration.writeZygoteSnapshot();</div><div class="line">4.zygote进程启动后进行内存回收调用gc：</div><div class="line">gcAndFinalize();</div><div class="line">//这对调用fork()出新子进程之前进程回收内存有用；</div><div class="line">static void gcAndFinalize() &#123;</div><div class="line">final VMRuntime runtime = VMRuntime.getRuntime();</div><div class="line"></div><div class="line">/* runFinalizationSync() lets finalizers be called in Zygote,</div><div class="line">* which doesn&apos;t have a HeapWorker thread.</div><div class="line">*/</div><div class="line">System.gc();</div><div class="line">runtime.runFinalizationSync();</div><div class="line">System.gc();</div><div class="line">&#125;</div><div class="line">5.startSystemServer，准备fork出进程的System server进程，所以</div><div class="line">我们知道新创建的进程由Zygote进程fork出来的，同时也会为这个进程</div><div class="line">fork唯一的SystemServer进程管理服务；</div></pre></td></tr></table></figure>
<ul>
<li>6.ZygoteConnection.runOnce，真正创建子进程的地方：调用Zygote.forkAndSpecialize,返回进程的pid；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">class ZygoteConnection &#123;  </div><div class="line">......  </div><div class="line"></div><div class="line">boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123;  </div><div class="line">String args[];  </div><div class="line">Arguments parsedArgs = null;  </div><div class="line">FileDescriptor[] descriptors;  </div><div class="line"></div><div class="line">try &#123;  </div><div class="line">args = readArgumentList();  </div><div class="line">descriptors = mSocket.getAncillaryFileDescriptors();  </div><div class="line">&#125; catch (IOException ex) &#123;  </div><div class="line">......  </div><div class="line">return true;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">......  </div><div class="line"></div><div class="line">/** the stderr of the most recent request, if avail */  </div><div class="line">PrintStream newStderr = null;  </div><div class="line"></div><div class="line">if (descriptors != null &amp;&amp; descriptors.length &gt;= 3) &#123;  </div><div class="line">newStderr = new PrintStream(  </div><div class="line">new FileOutputStream(descriptors[2]));  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">int pid;  </div><div class="line"></div><div class="line">try &#123;  </div><div class="line">parsedArgs = new Arguments(args);  </div><div class="line"></div><div class="line">applyUidSecurityPolicy(parsedArgs, peer);  </div><div class="line">applyDebuggerSecurityPolicy(parsedArgs);  </div><div class="line">applyRlimitSecurityPolicy(parsedArgs, peer);  </div><div class="line">applyCapabilitiesSecurityPolicy(parsedArgs, peer);  </div><div class="line"></div><div class="line">int[][] rlimits = null;  </div><div class="line"></div><div class="line">if (parsedArgs.rlimits != null) &#123;  </div><div class="line">rlimits = parsedArgs.rlimits.toArray(intArray2d);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</div><div class="line">parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</div><div class="line">parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</div><div class="line">parsedArgs.appDataDir);  </div><div class="line">&#125; catch (IllegalArgumentException ex) &#123;  </div><div class="line">......  </div><div class="line">&#125; catch (ZygoteSecurityException ex) &#123;  </div><div class="line">......  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">if (pid == 0) &#123;  </div><div class="line">// in child  </div><div class="line">handleChildProc(parsedArgs, descriptors, newStderr);  </div><div class="line">// should never happen  </div><div class="line">return true;  </div><div class="line">&#125; else &#123; /* pid != 0 */  </div><div class="line">// in parent...pid of &lt; 0 means failure  </div><div class="line">return handleParentProc(pid, descriptors, parsedArgs);  </div><div class="line">&#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">......  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>真正创建进程的地方就是在这里了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</div><div class="line">parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</div><div class="line">parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</div><div class="line">parsedArgs.appDataDir);</div></pre></td></tr></table></figure>
<p>这个函数会创建一个进程，而且有两个返回值，一个是在当前进程中返回的，一个是在新创建的进程中返回，即在当前进程的子进程中返回，在当前进程中的返回值就是新创建的子进程的pid值，而在子进程中的返回值是0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int pid = nativeForkAndSpecialize(</div><div class="line">uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</div><div class="line">instructionSet, appDataDir);</div><div class="line">if (pid == 0) &#123;</div><div class="line">Trace.setTracingEnabled(true);</div><div class="line"></div><div class="line">// Note that this event ends at the end of handleChildProc,</div><div class="line">Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;PostFork&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里会调用nativeForkAndSpecialize函数创建进程，pid==0的时候创建子进程，我们只看这里回调 Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, “PostFork”);，相当于一个消息机制，发出Postfork；</p>
<ul>
<li>7.ZygoteInit.startSystemServer()，fork出SystemServer进程；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private static boolean startSystemServer(String abiList, String socketName)</div><div class="line">throws MethodAndArgsCaller, RuntimeException &#123;</div><div class="line">......</div><div class="line">//fork 出SystemServer进程，得到进程的pid</div><div class="line">pid = Zygote.forkSystemServer(</div><div class="line">parsedArgs.uid, parsedArgs.gid,</div><div class="line">parsedArgs.gids,</div><div class="line">parsedArgs.debugFlags,</div><div class="line">null,</div><div class="line">parsedArgs.permittedCapabilities,</div><div class="line">parsedArgs.effectiveCapabilities);</div><div class="line">......</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>8.RuntimeInit.zygoteInit<br>这个函数定义在frameworks/base/core/java/com/android/internal/os/RuntimeInit.java文件中：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</div><div class="line">throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class="line">if (DEBUG) Slog.d(TAG, &quot;RuntimeInit: Starting application from zygote&quot;);</div><div class="line"></div><div class="line">Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;RuntimeInit&quot;);</div><div class="line">redirectLogStreams();</div><div class="line"></div><div class="line">commonInit();</div><div class="line">nativeZygoteInit();</div><div class="line">applicationInit(targetSdkVersion, argv, classLoader);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有两个关键的函数调用，一个是zygoteInitNative函数调用，一个是invokeStaticMain函数调用，这个在applicationInit方法里面，前者就是执行Binder驱动程序初始化的相关工作了，正是由于执行了这个工作，才使得进程中的Binder对象能够顺利地进行Binder进程间通信，而后一个函数调用，就是执行进程的入口函数，这里就是执行startClass类的main函数了，而这个startClass即是我们在Step 1中传进来的”android.app.ActivityThread”值，表示要执行android.app.ActivityThread类的main函数。我们先来看一下zygoteInitNative函数的调用过程，然后再回到RuntimeInit.zygoteInit函数中来，看看它是如何调用android.app.ActivityThread类的main函数的。</p>
<p>zygoteInitNative是一个native函数，实现在frameworks/base/core/jni/AndroidRuntime.cpp文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static AndroidRuntime* gCurRuntime = NULL; </div><div class="line">.......</div><div class="line">static void com_android_internal_os_RuntimeInit_zygoteInit(JNIEnv* env, jobject clazz)  </div><div class="line">&#123;  </div><div class="line">gCurRuntime-&gt;onZygoteInit();  </div><div class="line">&#125;  </div><div class="line">......</div></pre></td></tr></table></figure>
<ul>
<li>9.AppRuntime.onZygoteInit<br>这个函数定义在frameworks/base/cmds/app_process/app_main.cpp文件中：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class AppRuntime : public AndroidRuntime  </div><div class="line">&#123;  </div><div class="line">......  </div><div class="line"></div><div class="line">virtual void onZygoteInit()  </div><div class="line">&#123;  </div><div class="line">sp&lt;ProcessState&gt; proc = ProcessState::self();  </div><div class="line">if (proc-&gt;supportsProcesses()) &#123;  </div><div class="line">LOGV(&quot;App process: starting thread pool.\n&quot;);  </div><div class="line">proc-&gt;startThreadPool();  </div><div class="line">&#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">......  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里它就是调用ProcessState::startThreadPool启动线程池了，这个线程池中的线程就是用来和Binder驱动程序进行交互的了。ProcessState类是Binder进程间通信机制的一个基础组件，它会创建一个PoolThread线程类，然后执行它的run函数，最终就会执行PoolThread类的threadLoop函数了。这个线程会告诉binder机制它要进入循环，不断与binder驱动进行交互，获取client端的进程间调用，当线程退出后会调用</p>
<p>也会告诉Binder驱动程序，它退出了，这样Binder驱动程序就不会再在Client端的进程间调用分发给它了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mOut.writeInt32(BC_EXIT_LOOPER);  </div><div class="line">talkWithDriver(false);</div></pre></td></tr></table></figure></p>
<p>调用talkWithDriver和binder驱动交互，还有线程池，我们在开发Android应用程序的时候，当我们要和其它进程中进行通信时，只要定义自己的Binder对象，然后把这个Binder对象的远程接口通过其它途径传给其它进程后，其它进程就可以通过这个Binder对象的远程接口来调用我们的应用程序进程的函数了，它不像我们在C++层实现Binder进程间通信机制的Server时，必须要手动调用IPCThreadState.joinThreadPool函数来进入一个无限循环中与Binder驱动程序交互以便获得Client端的请求，这样就实现了我们在文章开头处说的Android应用程序进程天然地支持Binder进程间通信机制。</p>
<p>RuntimeInit.zygoteInit函数中，在初始化完成Binder进程间通信机制的基础设施后，它接着就要进入进程的入口函数了。<br>这个函数定义在frameworks/base/core/java/com/android/internal/os/RuntimeInit.java文件中：</p>
<ul>
<li><ol>
<li>RuntimeInit.invokeStaticMain</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class ZygoteInit &#123;  </div><div class="line">......  </div><div class="line"></div><div class="line">static void invokeStaticMain(ClassLoader loader,  </div><div class="line">String className, String[] argv)  </div><div class="line">throws ZygoteInit.MethodAndArgsCaller &#123;  </div><div class="line">Class&lt;?&gt; cl;  </div><div class="line"></div><div class="line">try &#123;  </div><div class="line">cl = loader.loadClass(className);  </div><div class="line">&#125; catch (ClassNotFoundException ex) &#123;  </div><div class="line">......  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">Method m;  </div><div class="line">try &#123;  </div><div class="line">m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);  </div><div class="line">&#125; catch (NoSuchMethodException ex) &#123;  </div><div class="line">......  </div><div class="line">&#125; catch (SecurityException ex) &#123;  </div><div class="line">......  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">int modifiers = m.getModifiers();  </div><div class="line">......  </div><div class="line"></div><div class="line">/* </div><div class="line">* This throw gets caught in ZygoteInit.main(), which responds </div><div class="line">* by invoking the exception&apos;s run() method. This arrangement </div><div class="line">* clears up all the stack frames that were required in setting </div><div class="line">* up the process. </div><div class="line">*/  </div><div class="line">throw new ZygoteInit.MethodAndArgsCaller(m, argv);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">......  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面我们说过，这里传进来的参数className字符串值为”android.app.ActivityThread”，这里就通ClassLoader.loadClass函数将它加载到进程中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cl = loader.loadClass(className);</div></pre></td></tr></table></figure>
<p>然后获得它的静态成员函数main：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</div></pre></td></tr></table></figure>
<p>最后调用ActivityThread类的入口main函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public final class ActivityThread &#123;  </div><div class="line">......  </div><div class="line"></div><div class="line">public static final void main(String[] args) &#123;  </div><div class="line">SamplingProfilerIntegration.start();  </div><div class="line"></div><div class="line">Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);  </div><div class="line"></div><div class="line">Looper.prepareMainLooper();  </div><div class="line">if (sMainThreadHandler == null) &#123;  </div><div class="line">sMainThreadHandler = new Handler();  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">ActivityThread thread = new ActivityThread();  </div><div class="line">thread.attach(false);  </div><div class="line"></div><div class="line">if (false) &#123;  </div><div class="line">Looper.myLooper().setMessageLogging(new  </div><div class="line">LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));  </div><div class="line">&#125;  </div><div class="line">Looper.loop();  </div><div class="line"></div><div class="line">if (Process.supportsProcesses()) &#123;  </div><div class="line">throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">thread.detach();  </div><div class="line">String name = (thread.mInitialApplication != null)  </div><div class="line">? thread.mInitialApplication.getPackageName()  </div><div class="line">: &quot;&lt;unknown&gt;&quot;;  </div><div class="line">Slog.i(TAG, &quot;Main thread of &quot; + name + &quot; is now exiting&quot;);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">......  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建ActivityThread 进入消息循环，这样，我们以后就可以在这个进程中启动Activity或者Service了。至此，Android应用程序进程启动过程的源代码就分析完成了，它除了指定新的进程的入口函数是ActivityThread的main函数之外，还为进程内的Binder对象提供了Binder进程间通信机制的基础设施，由此可见，Binder进程间通信机制在Android系统中是何等的重要，而且是无处不在。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/03/Android周报(三)/" rel="next" title="Android 博客">
                <i class="fa fa-chevron-left"></i> Android 博客
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/17/Android frameWork层(三)：Android应用程序安装过程PMS源码分析/" rel="prev" title="Android frameWork层——Android应用程序安装过程源码分析">
                Android frameWork层——Android应用程序安装过程源码分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1502346421&di=d5dddcc8504e58a709921075437056f6&imgtype=jpg&er=1&src=http%3A%2F%2Fww2.sinaimg.cn%2Fmw1024%2F64b5b174jw1esy5043qmtg206t07i7ol.gif"
               alt="dehao@yang" />
          <p class="site-author-name" itemprop="name">dehao@yang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-简介"><span class="nav-number">1.</span> <span class="nav-text">1.简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-启动过程分析"><span class="nav-number">2.</span> <span class="nav-text">2.启动过程分析</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dehao@yang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("SQRi8Ar8YCn4c3G97nJ9JsoK-gzGzoHsz", "Hu3hKNQdfDQNJ6zYikQwidIj");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
